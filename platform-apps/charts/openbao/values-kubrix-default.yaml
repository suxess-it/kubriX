eso:
  providerUrl: "http://sx-openbao-active.openbao.svc.cluster.local:8200"
  backendName: openbao-backend
  secretStore: kubrix-kv

crossplane:
  activeMRDs:
    audits.vault.vault.upbound.io: true
    mounts.vault.vault.upbound.io: true
    policies.vault.vault.upbound.io: true
    authbackendroles.kubernetes.vault.upbound.io: true
    groups.identity.vault.upbound.io: true
    secretbackendv2s.kv.vault.upbound.io: true
    authbackendroles.token.vault.upbound.io: true
    tokens.vault.vault.upbound.io: true

openbao:
  injector:
    enabled: false
  server:
    ingress:
      enabled: true
      ingressClassName: nginx
      annotations:
        external-dns.alpha.kubernetes.io/ttl: "60"
        cert-manager.io/cluster-issuer: default-issuer
      hosts: []
      tls: []
    extraInitContainers:
      - name: utility-downloader
        image: alpine/curl:latest
        command:
        - /bin/sh
        - -c
        - |
            set -euo pipefail
            cd /usr/local/libexec/vault
            ver="$(curl -fsSL --retry 10 --retry-all-errors --retry-delay 5 \
              https://dl.k8s.io/release/stable.txt)"
            curl -fL --retry 10 --retry-all-errors --retry-delay 5 \
             -o kubectl "https://dl.k8s.io/release/${ver}/bin/linux/amd64/kubectl"
            chmod +x kubectl
            curl -L -o jq https://github.com/stedolan/jq/releases/download/jq-1.8.1/jq-linux64
            chmod +x jq
        volumeMounts:
          - name: plugins
            mountPath: /usr/local/libexec/vault
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - ALL
          privileged: false
          runAsNonRoot: true
    extraContainers:
      - name: auto-initializer
        image: quay.io/openbao/openbao:2.5.0
        env:
          - name: VAULT_ADDR
            valueFrom:
              secretKeyRef:
                name: sx-openbao-env-vars
                key: VAULT_ADDR
        command:
        - /bin/sh
        - -c
        - |
            while true; do
              sleep 10
              while [ -z $UNSEAL_KEY ]; do
                sleep 5
                VAULT_STATUS=$(bao status)
                if echo "$VAULT_STATUS" | grep -q "Initialized.*false" && [ $HOSTNAME = 'sx-openbao-0' ]; then
                  export INIT_RESPONSE=$(bao operator init -format=json -key-shares=1 -key-threshold=1)
                  echo "$INIT_RESPONSE"
                  export UNSEAL_KEY=$(echo "$INIT_RESPONSE" | /usr/local/libexec/vault/jq -r .unseal_keys_b64[0])
                  export ROOT_TOKEN=$(echo "$INIT_RESPONSE" | /usr/local/libexec/vault/jq -r .root_token)
                  echo "$UNSEAL_KEY"
                  echo "$ROOT_TOKEN"
                  /usr/local/libexec/vault/kubectl delete secret openbao-init -n openbao
                  /usr/local/libexec/vault/kubectl create secret generic openbao-init -n openbao --from-literal=unseal_key=${UNSEAL_KEY} --from-literal=root_token=${ROOT_TOKEN}
                else
                  echo "Vault Initialized"
                fi
              done
            done
        volumeMounts:
          - name: plugins
            mountPath: /usr/local/libexec/vault
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - ALL
          privileged: false
          runAsNonRoot: true

      - name: auto-unsealer
        image: quay.io/openbao/openbao:2.5.0
        env:
          - name: VAULT_ADDR
            valueFrom:
              secretKeyRef:
                name: sx-openbao-env-vars
                key: VAULT_ADDR
        command:
        - /bin/sh
        - -c
        - |
            while true; do
              sleep 10
              VAULT_STATUS=$(bao status)
              if echo "$VAULT_STATUS" | grep -q "Initialized.*false" && [ $HOSTNAME != 'sx-openbao-0' ]; then
                echo joining raft cluster
                bao operator raft join http://sx-openbao-0.sx-openbao-internal:8200
                sleep 5
              fi
              if echo "$VAULT_STATUS" | grep -q "Initialized.*true"; then
                if echo "$VAULT_STATUS" | grep -q "Sealed.*true"; then
                  if [ -f /vault-root-token/unseal_key ]; then
                    bao operator unseal $(cat /vault-root-token/unseal_key)
                    sleep 5
                  else
                    echo unseal key not initialized yet
                  fi
                else
                  echo vault already unsealed
                fi
              else
                echo Vault not initialized yet
              fi
            done
        volumeMounts:
          - name: vault-root-token
            mountPath: /vault-root-token
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - ALL
          privileged: false
          runAsNonRoot: true
      - name: vault-initializer
        image: quay.io/openbao/openbao:2.5.0
        env:
          - name: VAULT_ADDR
            valueFrom:
              secretKeyRef:
                name: sx-openbao-env-vars
                key: VAULT_ADDR
        command:
        - /bin/sh
        - -c
        - |
          while true; do
            sleep 10

            if [ -f /vault-root-token/root_token ]; then
              export VAULT_TOKEN="$(cat /vault-root-token/root_token)"

              if bao status | grep -q "Sealed.*false"; then
                # only run setup when admins group does NOT exist
                if ! bao read identity/group/name/admins >/dev/null 2>&1; then
                  # enable audit device once during initial setup
                  bao audit enable file file_path=stdout
                  # kubernetes auth backend
                  if ! bao read auth/kubernetes/config >/dev/null 2>&1; then
                    bao auth enable kubernetes || true
                    bao write auth/kubernetes/config \
                      token_reviewer_jwt="$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)" \
                      kubernetes_host="https://${KUBERNETES_PORT_443_TCP_ADDR:-$KUBERNETES_SERVICE_HOST}:443" \
                      kubernetes_ca_cert=@/var/run/secrets/kubernetes.io/serviceaccount/ca.crt
                  fi

                  # crossplane role
                  if ! bao read auth/kubernetes/role/crossplane >/dev/null 2>&1; then
                    CROSSPLANETOKEN="$(bao token create -display-name=crossplane-token -policy=root -format=json \
                     | /usr/local/libexec/vault/jq -r '.auth.client_token')"
                    /usr/local/libexec/vault/kubectl delete secret crossplane-init -n openbao --ignore-not-found
                    /usr/local/libexec/vault/kubectl create secret generic crossplane-init -n openbao \
                      --from-literal=credentials='{"token":"'"$CROSSPLANETOKEN"'"}'

                    bao write auth/kubernetes/role/crossplane \
                      bound_service_account_names="*" \
                      bound_service_account_namespaces=crossplane \
                      policies=crossplane \
                      ttl=24h \
                      audience=crossplane
                  fi
                else
                  echo "setup complete"
                fi
              else
                echo "vault still sealed"
              fi
            else
              echo "root token not initialized yet"
            fi
          done
        volumeMounts:
          - name: vault-root-token
            mountPath: /vault-root-token
          - name: plugins
            mountPath: /usr/local/libexec/vault
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - ALL
          privileged: false
          runAsNonRoot: true
    volumes:
      - name: plugins
        emptyDir: {}
      - name: vault-root-token
        secret:
          secretName: openbao-init
          optional: true
    volumeMounts:
      - mountPath: /usr/local/libexec/vault
        name: plugins
        readOnly: false
    dataStorage:
      size: 1Gi
    affinity: {}
    ha:
      enabled: true
      replicas: 1
      raft:
        enabled: true
        setNodeId: true
        config: |
          ui = true

          listener "tcp" {
            tls_disable = 1
            address = "[::]:8200"
            cluster_address = "[::]:8201"
            # Enable unauthenticated metrics access (necessary for Prometheus Operator)
            telemetry {
              unauthenticated_metrics_access = "true"
            }
          }

          storage "raft" {
            path = "/openbao/data"
          }

          telemetry {
            prometheus_retention_time = "30m"
            disable_hostname = true
          }

          service_registration "kubernetes" {}
          plugin_directory = "/usr/local/libexec/vault"
          unsafe_allow_api_audit_creation = true
      config: |
        allow_audit_log_prefixing: true
  serverTelemetry:
    serviceMonitor:
      enabled: true
  prometheusRules:
    enabled: true
