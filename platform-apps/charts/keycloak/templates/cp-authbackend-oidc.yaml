# we add this Job in a sync-wave before the oidc-backend AuthBackend so we can be sure that the keycloak URL (oidcDiscoveryUrl) is reachable via curl and has a valid TLS certificate applied
# because otherwise it could be that AuthBackend is created, wants to call the oidcDiscoveryUrl, that is not reachable or has a not valid TLS certificate, 
# then the AuthBackend gets created but the managed resource is unhealthy and needs manual intervention
apiVersion: batch/v1
kind: Job
metadata:
  name: curl-oidc-discovery-url
  namespace: vault
  annotations:
    argocd.argoproj.io/sync-wave: "2"
spec:
  # Optional: hard cap so Kubernetes kills the Pod if it runs too long.
  # Keep this >= TIMEOUT_SECONDS.
  activeDeadlineSeconds: 360
  backoffLimit: 0          # we handle retries inside the container
  template:
    spec:
      restartPolicy: Never
      containers:
      - name: curl
        image: curlimages/curl:latest
        env:
          - name: URL
            value: "https://keycloak{{ .Values.kubrix.keycloak.domainName }}/realms/{{ $.Values.kubrix.keycloak.realm.realmid }}"
          - name: TIMEOUT_SECONDS
            value: "300"                          # total time to keep trying
          - name: SLEEP_SECONDS
            value: "5"                            # wait between attempts
{{- if (contains "nip.io" .Values.kubrix.keycloak.domainName ) }}
          - name: CURL_CA_BUNDLE
            value: "/etc/ssl/custom/ca.crt"
        volumeMounts:
          - name: ca-cert
            mountPath: /etc/ssl/custom
            readOnly: true
{{- end }}
        command:
          - sh
          - -c
          - |
            start=$(date +%s)
            end=$((start + TIMEOUT_SECONDS))
            echo "Probing $URL with custom CA ($CURL_CA_BUNDLE) for up to ${TIMEOUT_SECONDS}s ..."
            while [ "$(date +%s)" -lt "$end" ]; do
              if curl -fsS "$URL" > /dev/null; then
                echo "Success: $URL is reachable."
                exit 0
              fi
              echo "Not ready yet. Retrying in ${SLEEP_SECONDS}s ..."
              sleep "$SLEEP_SECONDS"
            done
            echo "Timed out after ${TIMEOUT_SECONDS}s waiting for $URL"
            exit 1
{{- if (contains "nip.io" .Values.kubrix.keycloak.domainName ) }}
      volumes:
        - name: ca-cert
          secret:
            secretName: ca-cert
            items:
              - key: ca.crt
                path: ca.crt
                mode: 0444
{{- end }}
---
apiVersion: jwt.vault.upbound.io/v1alpha1
kind: AuthBackend
metadata:
  name: oidc-backend
  annotations:
    argocd.argoproj.io/sync-options: SkipDryRunOnMissingResource=true
    argocd.argoproj.io/sync-wave: "3"
spec:
  providerConfigRef:
    name: vault-crossplane-providerconfig
  forProvider:
    oidcDiscoveryUrl: "https://keycloak{{ .Values.kubrix.keycloak.domainName }}/realms/{{ $.Values.kubrix.keycloak.realm.realmid }}"
    oidcClientId: vault
    defaultRole: default
    oidcClientSecretSecretRef:
      name: keycloak-client-credentials
      key: vault
      namespace: keycloak
    type: oidc
    path: oidc
  #  oidcDiscoveryCaPem: "/vault/userconfig/vault-ca/ca.crt"
# tune not working?
---
apiVersion: jwt.vault.upbound.io/v1alpha1
kind: AuthBackendRole
metadata:
  name: oidc-backend-role
  annotations:
    argocd.argoproj.io/sync-options: SkipDryRunOnMissingResource=true
    argocd.argoproj.io/sync-wave: "7"
spec:
  providerConfigRef:
    name: vault-crossplane-providerconfig
  forProvider:
    allowedRedirectUris: 
    - https://vault{{ .Values.kubrix.keycloak.domainName }}/ui/vault/auth/oidc/oidc/callback
    - http://localhost:8250/oidc/callback
    roleName: default
    userClaim: sub
    groupsClaim: roles
    tokenPolicies: 
    - default
    tokenNoDefaultPolicy: true
    tokenType: service
    verboseOidcLogging: true
    oidcScopes:
    - groups
    roleType: oidc
    backend: oidc
   # policies: default #needed?
